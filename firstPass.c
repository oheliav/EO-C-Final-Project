#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "firstPass.h"
#include "globals.h"
#include "dataStructures.h"
#include "util.h"
#include "errors.h"
#include "bitUtils.h"

// Function that runs the first pass
int firstPass(char *filename) {
    
    FILE *fp = fopen(filename, "r");  // Open the file generated by the pre-assembler
    
    /*if (fp == NULL) {
        printf("Error: Unable to open the file '%s'.\n", filename);
        return 0;  // Return 0 to indicate failure
    }*/

    foundError =  0;
    counter = 1;
    char line[MAX];
    //step 1, init IC & DC
    IC = 100;
    DC = 0;

    while (fgets(line, MAX, fp) != NULL) { //Step 2, read next line from the source code
        // Remove any trailing newline character from the line
        line[strcspn(line, "\n")] = '\0';
        
        /* That was debug line
        if (foundError == 1){
            printf("Error in line: %d \n", counter);
            return 0;
        }*/

        // Process each line using processLine()
        processLine(line, &IC, &DC);
        counter++;
    }

    fclose(fp);  // Close the file after processing

    // Step 17: If no errors were found, update data symbols
    if (foundError == 1) {
        return 0;  // If there were errors during the first pass, return failure
    }
    // Step 18
    ICF = IC; 
    IDF = DC;

    updateDataSymbols(symbolTable);  // Update the value of data symbols by adding IC, step 19

    // Return 1 for success
    return 1;
}

/**
 * @brief Determines the type of a given line in the assembly source.
 * 
 * @param line Pointer to the line to analyze.
 * @return int Returns:
 *         0 if the line is a comment,
 *         1 if the line is a data store directive (.data or .string),
 *         2 if the line is an entry or extern directive (.entry or .extern),
 *         3 if the line contains an opcode,
 *        -1 if the line contains an invalid or unrecognized directive.
 */
int determineLineType(char *line) {
    char firstWord[MAX];
    char rest[MAX];

    /* Extract the first word from the line */
    sscanf(line, "%s", firstWord);

    /* Check for comment lines */
    if (firstWord[0] == ';') {
        return 0;  /* Comment line */
    }

    /* Check if the first word is a potential symbol */
    if (isSymbolFormat(firstWord)) {
        strcpy(rest, skipFirstWord(line));
        sscanf(rest, "%s", firstWord);
    }

    /* Check for directives (lines starting with '.') */
    if (firstWord[0] == '.') {
        if (strcmp(firstWord, ".data") == 0 || strcmp(firstWord, ".string") == 0) {
            return 1;  /* Data store line */
        } 
        if (strcmp(firstWord, ".extern") == 0 || strcmp(firstWord, ".entry") == 0) {
            return 2;  /* Extern or entry directive */
        } 
        raiseError("Invalid directive in line %d\n", counter);
        return -1;
    }

    /* Check if the first word is an opcode */
    if (isOpcode(firstWord)) {
        return 3;  /* Opcode line */
    }

    /* Unrecognized line */
    raiseError("Unrecognized: %s in line %d\n", firstWord, counter);
    return -1;
}

void processLine(char *line, int *IC, int *DC) {
    
    printf("Processing line: %s\n", line);
    char firstWord[MAX];
    int num = determineLineType(line);
    int symbolFlag = 0;
    int L = 0;
    char name[MAX];
    int value;
    sscanf(line, "%s", firstWord);

    if (num == -1) {
        // Debug
        printf("Found error in line\n");
        return;
    }

    if (num == 0) {
        printf("comment"); //Debug line
        return;  // comment line
    }
    
    if (isSymbolFormat(firstWord)) {  // step 3
        printf("Found Potentiel Symbol: %s \n", firstWord); //Debug line
        symbolFlag = 1;  // step 4
    }
    
     // .string or .data directive, step 5
    if (num == 1) {  

        printf("Should be .data or .string\n"); //Debug line

        // If there's a symbol, add it to the table
        if (symbolFlag && isValidSymbol(firstWord)) {
            strcpy(name, firstWord);
            addSymbolToTable(name, *DC, "data", NULL, NULL); //step 6
        }

        //step 7
        // Handle .string
        if (strstr(line, ".string")) {
            char *stringContent = strchr(line, '"');
            if (stringContent != NULL) {
                stringContent++;  // Skip the opening quote
                char *endQuote = strchr(stringContent, '"');
                if (endQuote != NULL) {
                    *endQuote = '\0';  // Null-terminate the string
                    parseString(stringContent, DC);  // Pass DC to update it inside parseString, isn't DC a global tho?
                } else {
                    printf("Error: Unterminated string in .string directive.\n");
                }
            } else {
                printf("Error: Missing string in .string directive.\n");
            }
        }

        // Handle .data
        else if (strstr(line, ".data")) {
            char *dataContent = strstr(line, ".data");
            if (dataContent) {
                dataContent += strlen(".data");  // Skip ".data"
                parseData(dataContent, DC);  // Pass DC to update it inside parseData
            }
        }

        return;
    }
    
    if (num == 2) { //step 8
        if (isSymbolFormat(firstWord)){
            printf("Line %d: Label isn't allowed in a .extern or .entry line and is ignored\n", counter); //Raise warning, create in errors
        }
        if (strcmp(firstWord, ".entry") == 0){ //step 9
            return;
        }
        if (strcmp(firstWord, ".extern") == 0){ 
            int numOfLabels;
            char **labelsPassed = parseExternLine(line, &numOfLabels);

            if (labelsPassed != NULL){
                for (int i = 0; i < numOfLabels; i++){
                    addSymbolToTable(labelsPassed[i], 0, "external", NULL, NULL); //step 10
                    free(labelsPassed[i]);
                }
            free(labelsPassed);
            }
        }
        return;
    }

    if (symbolFlag) {  // step 11: Symbol is present

        if (isValidSymbol(firstWord)) {  // Check if the symbol is valid
            // Remove the colon from the symbol (create a copy without the colon)
            char symbolName[MAX];
            strncpy(symbolName, firstWord, strlen(firstWord) - 1);
            symbolName[strlen(firstWord) - 1] = '\0';  // Null-terminate the string

            printf("Inserting symbol: %s to table with property code\n", symbolName);
            // Insert the symbol into the symbol table with the value IC

            int val = *IC;
            printf("value: %d\n", val);
            addSymbolToTable(symbolName, *IC, "code", NULL, NULL);  // Insert symbol
            printf("Symbol '%s' added to the table with value %d.\n", symbolName, *IC);
        } else {
            raiseError("Invalid symbol in line %d\n", counter);
        }
    }

    // I got to step 12
    if (num == 3){
        printf("This is an Opcode line.\n"); //Debug line
        L = parseOpcodeLine(line); // step 14: Calculate L (number of words for machine code)

    }

    // step 16: Update IC
    *IC += L; 
    printf("IC after update is: %d\n", *IC);
    return;
}

// Function to generate the first word of machine code in the correct bit order
char *generateFirstWord(Opcode *opcode, int mode1, int mode2, int registerNum1, int registerNum2) {
    // Allocate memory for the 24-bit binary string (+1 for null terminator)
    char *binaryMachineCode = (char *)malloc(25 * sizeof(char));  
    if (binaryMachineCode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);  // Exit if memory allocation fails
    }
    // Initialize the machine code with 0s
    memset(binaryMachineCode, '0', 24);
    binaryMachineCode[24] = '\0';  // Null-terminate the string

    // Convert the opcode value to a 4-bit binary string
    char *binaryOpcode = intTo6BitBinary(opcode->value);
    char *binaryFunct = (opcode->funct != -1) ? intTo5BitBinary(opcode->funct): "00000";
    // Convert mode1 and mode2 to 2-bit binary strings if valid
    char *binaryMode1 = (mode1 != -1) ? intTo2BitBinary(mode1) : "00";
    char *binaryMode2 = (mode2 != -1) ? intTo2BitBinary(mode2) : "00";
    // Convert register numbers to 3-bit binary if exist
    char *binarySourceReg = (registerNum1 != -1) ? intTo3BitBinary(registerNum1) : "000";
    char *binaryTargetReg = (registerNum2 != -1) ? intTo3BitBinary(registerNum2) : "000";
    // Now fill the binary string in reverse order
    // Bits 23-18: Opcode value (6 bits, reverse order)
    binaryMachineCode[0]  = binaryOpcode[0];  // Bit 6 (opcode LSB)
    binaryMachineCode[1]  = binaryOpcode[1];  // Bit 6 (opcode LSB)
    binaryMachineCode[2]  = binaryOpcode[2];  // Bit 6 (opcode LSB)
    binaryMachineCode[3]  = binaryOpcode[3];  // Bit 7
    binaryMachineCode[4]  = binaryOpcode[4];  // Bit 8
    binaryMachineCode[5]  = binaryOpcode[5];  // Bit 9 (opcode MSB)

    // Bits 17-16: Source Operand Addressing Mode (mode1)
    binaryMachineCode[6]  = binaryMode1[0];  // Bit 4 (mode1 LSB)
    binaryMachineCode[7]  = binaryMode1[1];  // Bit 5 (mode1 MSB)


    // Bits 15-13: Source Register
    binaryMachineCode[8] = binarySourceReg[0];
    binaryMachineCode[9] = binarySourceReg[1];
    binaryMachineCode[10] = binarySourceReg[2];

    // Bits 12-11: Target Operand Addressing Mode (mode2)
    binaryMachineCode[11] = binaryMode2[0];  // Bit 2 (mode2 LSB)
    binaryMachineCode[12] = binaryMode2[1];  // Bit 3 (mode2 MSB)

    // Bits 10-8: Target Register
    binaryMachineCode[13] = binaryTargetReg[0];
    binaryMachineCode[14] = binaryTargetReg[1];
    binaryMachineCode[15] = binaryTargetReg[2];

    // Bits 7-3: Funct value in 5-bit binary
    binaryMachineCode[16] = binaryFunct[0];
    binaryMachineCode[17] = binaryFunct[1];
    binaryMachineCode[18] = binaryFunct[2];
    binaryMachineCode[19] = binaryFunct[3];
    binaryMachineCode[20] = binaryFunct[4];

    // Bits 2-0: A,R,E (always "100")
    binaryMachineCode[21] = '1';  // Bit 2 - A
    binaryMachineCode[22] = '0';  // Bit 1 - R
    binaryMachineCode[23] = '0';  // Bit 0 - E

    // Free dynamically allocated memory
    free(binaryOpcode);
    
    return binaryMachineCode;  // Return the correctly ordered binary machine code string
}

// Main function to find the addressing mode of an operand
int findAddressingMode(char *operand) {
    // Step 1: Check for Immediate Addressing (starts with '#')
    if (operand[0] == '#') {
        char immediateValue[MAX];  // Buffer to hold the rest of the operand
        strncpy(immediateValue, operand + 1, MAX - 1);  // Copy everything after the '#'
        immediateValue[MAX - 1] = '\0';  // Ensure null-termination
        
        if (isValidInteger(immediateValue)) {
            return 0;  // Immediate addressing
        } else {
            raiseError("Integer in immidiate addressing is invalid\n");
            return -1;
        }
    }

    // Step 2: Check for Relative Addressing (starts with '&' followed by a label)
    if (operand[0] == '&') {
        char relativeLabel[MAX];
        strncpy(relativeLabel, operand + 1, MAX - 1);  // Extract everything after '&'
        relativeLabel[MAX - 1] = '\0';

        if (isValidOperandSymbol(relativeLabel)) {
            return 2;  // Relative addressing
        } else {
            raiseError("Symbol in operand is in valid in line %d\n", counter);
            return -1;
        }
    }

    // Step 3: Check for Direct Register Addressing (R0, R1, etc.)
    if (isRegisterName(operand)) {
        printf("%s is a valid register addressing\n", operand);
        return 3;  // Direct Register Addressing
    }

    // Step 4: Check for Direct Addressing (label)
    if (isValidOperandSymbol(operand)) {
        return 1;  // Direct Addressing
    }

    // Invalid operand
    printf("Error: Invalid operand '%s'\n", operand);
    return -1;  // Indicate invalid addressing mode
}
